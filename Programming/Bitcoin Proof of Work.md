# What is Proof of Work in Bitcoin?

A simple example (generated by ChatGPT-4o) to demonstrate how Proof-of-Work is done in bitcoin mining:

```python
import hashlib
import time

def mine_block(data, difficulty_bits):
    """
    Mines a block by finding a nonce that makes the hash start with difficulty_bits zeros.
    :param data: string data of the block
    :param difficulty_bits: number of leading zero bits required
    :return: (nonce, hash, time_taken)
    """
    prefix_zeros = '0' * difficulty_bits
    nonce = 0
    start_time = time.time()

    while True:
        text = f"{data}{nonce}".encode()
        hash_result = hashlib.sha256(text).hexdigest()
        # Check if hash starts with required zeros
        if hash_result.startswith(prefix_zeros):
            end_time = time.time()
            return nonce, hash_result, end_time - start_time
        nonce += 1

# Example usage:
difficulty = 4  # Number of leading zeros required (higher = harder)
block_data = "Sample block data"

nonce, block_hash, duration = mine_block(block_data, difficulty)

print(f"Nonce found: {nonce}")
print(f"Hash: {block_hash}")
print(f"Time taken: {duration:.2f} seconds")

```

A more realistic example (also generated by ChatGPT-4o):

```python
import hashlib
import time

def double_sha256(data):
    """Bitcoin uses double SHA-256 hashing."""
    return hashlib.sha256(hashlib.sha256(data).digest()).digest()

def mine_block(block_header, target):
    """
    Mines a block by finding a nonce that makes the double SHA-256 hash
    less than the target.
    
    :param block_header: bytes representing block header (simplified)
    :param target: integer target threshold
    :return: (nonce, hash_hex, time_taken)
    """
    nonce = 0
    start_time = time.time()
    
    while nonce < 0xFFFFFFFF:
        # Construct header with nonce (4 bytes little-endian)
        header_with_nonce = block_header + nonce.to_bytes(4, byteorder='little')
        
        hash_result = double_sha256(header_with_nonce)
        hash_int = int.from_bytes(hash_result[::-1], byteorder='big')  # Bitcoin uses little-endian hash display
        
        if hash_int < target:
            end_time = time.time()
            return nonce, hash_result.hex(), end_time - start_time
        nonce += 1
        
    return None, None, None  # Mining failed within nonce range

# Example usage:

# Simplified block header (just some bytes for demo; real headers are 80 bytes)
block_header = b"Example block header data"  

# Example difficulty target (lower = harder)
# Bitcoin's actual target is a 256-bit number; here we simulate a very high target for demo.
difficulty_target = 0x00000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

print("Mining started...")
nonce, block_hash, duration = mine_block(block_header, difficulty_target)

if nonce is not None:
    print(f"Nonce found: {nonce}")
    print(f"Hash: {block_hash}")
    print(f"Time taken: {duration:.2f} seconds")
else:
    print("Failed to find a valid nonce.")
```

Essentially:

- Miners compete to find a nonce that, when combined with the block header and transaction data and hashed twice using SHA-256, results in a hash that is numerically lower than a network-defined target.

- This process is computationally intensive and probabilistic — miners are essentially guessing trillions of nonces per second.

- The network adjusts the difficulty (i.e., the target value) every 2016 blocks (~2 weeks).

    - If blocks were mined too quickly (faster than 10 minutes on average), the difficulty is increased by lowering the target value.

    - If blocks were mined too slowly, the difficulty is decreased by raising the target.

    - This maintains an average block time of 10 minutes, regardless of how much computing power joins the network.

**Transaction Fees**:

- Each transaction can include a fee, which is an incentive for miners to include it in a block.

- Fees are not fixed; they are market-driven. Users who want faster confirmation typically set a higher fee to outbid others.

- The miner who successfully mines the block keeps all included transaction fees, in addition to the fixed block subsidy (currently 3.125 BTC as of the 2024 halving).

- When miners construct a new block, they select transactions from the mempool (pending transaction queue).

- Highest-fee-per-byte transactions are prioritised, since block space is limited (1–4 MB with SegWit).

- Low-fee transactions may:

        - Be delayed (if fee is too low relative to current demand).

        - Be dropped from the mempool (if unconfirmed for too long and mempool is full).

--- 

Reading up on this to better follow "Attack of the 50 foot Blockchain by David Gerard"